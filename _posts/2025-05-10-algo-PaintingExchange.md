---
title: "[알고리즘] 백준 1029 그림 교환"
date: 2025-05-10 18:00:00 +0900
categories: [알고리즘, 백준]
tags: [알고리즘, 백준, DP, 다이나믹 프로그래밍, 비트마스킹]
---


오늘 풀이할 알고리즘은 백준 사이트의 [그림 교환](https://www.acmicpc.net/problem/1029)라는 문제이며 코드는 파이썬으로 작성되어 있습니다.

---
### 요약

**N 명의 예술가**가 존재하며
최초에 **1번 예술가**가 외부에서 **0 의 가격**에 그림을 사옵니다.
**특정 조건**에 맞춰 그림을 거래할 수 있습니다.
1. 자신이 산 가격보다 **같거나 큰** 가격으로 팔아야 함
2. 같은 그림을 **두 번 이상** 사는 것을 **불가능**

조건을 만족하는 거래만이 이루어질 때 **그림을 소유했던 사람의 수의 최대값**을 출력하는 문제입니다.

---

### 문제조건 

2 ≤ N ≤ 15

0 <= 그림 가격 <= 9

제한 

메모리 128MB , 시간 2초 

( Pypy3 시간 제한: ×3+2 초 메모리 제한: ×2+128 MB )

---

### 풀이

DP 로 활용할 3차원 자료구조를 하나 만듭니다. 

저는 bit_group 이라는 이름으로 지었습니다.

다음과 같이 정보를 저장할 겁니다.

bit_group[그룹의 크기][그룹정보(비트마스크)][현재 그림을 소유한 예술가 번호] = 그림 가격

그룹의 크기가 작은 것부터 순차적으로 채운 후

존재하는 그룹의 크기가 가장 큰 것을 출력합니다.

---

### 해설

문제 입력은 다음과 같습니다.
```
5          N 예술가의 수
15555      i번째 줄 j번째 수 = i번 예술가가 j번 예술가에게 그림을 파는 가격
11111
15111
11111
11111
```

처음에 1번 예술가가 0 의 가격에 그림을 사옵니다.

주어진 입력 정보(graph)인 i번 예술가가 j번 예술가에게 그림을 파는 가격을

DP 자료구조에 담습니다.

bit_group[그룹의 크기][그룹정보(비트마스크)][현재 그림을 소유한 예술가 번호] = 그림 가격

ex) 1번이 2번에게 파는 정보를 저장한다면

1. 그룹의 크기는 1번, 2번 이므로 2

2. 그룹정보 는 1번과 2번 예술가가 그림을 소유했었음을 표현하기 위해 비트마스킹으로 저장합니다.

3. 2번 예술가가 현재 그림을 소유함

```bit_group[2][1<<1|1<<2][2] = graph[1][2]``` 과 같은 코드로 저장합니다.


이후 그룹의 크기 3, 4, 5, ... N 까지의 정보를 다음과 같은 로직으로 순차적으로 채워나갑니다.

1. 이미 만들어진 크기 i-1 의 그룹 하나(group)를 뽑아옵니다.
2. 해당 그룹에서 현재 그림을 소유한 예술가(leaf)를 뽑아옵니다.
  - 같은 그룹이라도 판매 경로에 따라 소유한 예술가가 다를 수 있음
  - 1 -> 5 -> 3 -> 7 
  - 1 -> 3 -> 7 -> 5 
  - 1 -> 7 -> 5 -> 3
3. 2번 ~ N번 예술가 중 그룹에 속하지 않은 예술가인지 확인합니다.
4. 헤당 예술가에게 판매할 수 있는지(샀던 가격보다 같거나 큰 경우)를 검증합니다.
5. 이미 만들어진 그룹. 예술가 정보가 있다면 최소값을 저장합니다.
   - 최대한 낮은 가격으로 계속해서 팔아야 많은 사람이 소유할 수 있음
   - 이미 만들어진 그룹이 존재하는 경우에 대한 예시
     - 아래 3 가지 경우 크기 4, 5 모두 그룹정보는 동일함
     - 하지만 7 이 6 에게 파는 가격
     - 5 가 6 에게 파는 가격
     - 3이 6 에게 파는 가격은 모두 다를 수 있음
     - 1 -> 5 -> 3 -> 7 -> 6 \ bit_group[5][group][6] = 7-> 6에게 판 가격
     - 1 -> 3 -> 7 -> 5 -> 6 \ bit_group[5][group][6] = 5-> 6에게 판 가격
     - 1 -> 7 -> 5 -> 3 -> 6 \ bit_group[5][group][6] = 3-> 6에게 판 가격

```python
# 만들고자 하는 그룹의 크기 i
for i in range(3, N+1):
    # 1. i-1 크기의 그룹 중 하나를 뽑아옴
    for group in bit_group[i-1]:
        # 현재 그림을 소유한 예술가를 뽑아옴
        for leaf in bit_group[i-1][group]:
            for j in range(1, N):
                # 3. 이미 그룹에 속해 있는가
                if group & 1<<j: 
                    continue
                # 4. 판매할 수 있는가
                if graph[leaf][j] >= bit_group[i-1][group][leaf]:
                    # 5. 이미 존재하는지 여부
                    if bit_group[i][group|1<<j].get(j):
                        bit_group[i][group|1<<j][j] = min(graph[leaf][j], bit_group[i][group|1<<j][j])
                    else:
                        bit_group[i][group|1<<j][j] = graph[leaf][j]
```

### 코드

```python
import sys
from collections import defaultdict
_input = sys.stdin.readline
def minput(): return map(int, _input().rstrip())

N = int(_input())
graph = [list(minput()) for _ in range(N)]
bit_group = [defaultdict(dict) for _ in range(16)]
bit_group[1][1][0] = 0 # bit_group[그룹크기][그룹비트마스크][리프노드번호]

for i in range(1, N):
    bit_group[2][1<<0|1<<i][i] = graph[0][i]

for i in range(3, N+1):
    for group in bit_group[i-1]:
        for leaf in bit_group[i-1][group]:
            for j in range(1, N):
                # j 에 대한 검증
                if group & 1<<j:
                    continue
                if graph[leaf][j] >= bit_group[i-1][group][leaf]:
                    if bit_group[i][group|1<<j].get(j):
                        bit_group[i][group|1<<j][j] = min(graph[leaf][j], bit_group[i][group|1<<j][j])
                    else:
                        bit_group[i][group|1<<j][j] = graph[leaf][j]

for i in range(1, 16):
    if bit_group[i]:
        continue
    else:
        print(i-1)
        break
else:
    print(i)
```

---

### 고찰

문제를 처음 직면하면 N이 작기때문에 완전탐색을 떠올릴 수는 있겠습니다만

15명 중 1명을 택하고 14명 중 1명을 택하고 ... 이어나가면 15! 팩토리얼에 해당하는 연산량이 필요합니다.

우선 문제에서 1번 에술가가 외부 상인으로부터 0 의 가격에 사오므로

1번이 각각의 예술가에게 파는 정보를 어떻게 담을 지에 대한 고민과 이를 해결한다면

그룹의 크기를 키워나가면서 필요한 정보들을 구해내는게 가능하겠습니다.

예술가들이 그림을 파는 정보를 어떻게 저장할 것인가와

그룹 크기 i-1 을 이용해서 그룹 크기 i 정보를 채워나가는 점화식에 대한 부분을 고민하다보면 자연스럽게 푸실 수 있을 겁니다.
